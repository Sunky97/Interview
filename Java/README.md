# Java
🔖 Contents

- [Java 와 C 의 차이점](#Java-와-C-의-차이점)
- [Java 언어의 장단점](#Java-언어의-장단점)
- [접근제어자의 종류와 특징](#접근제어자의-종류와-특징)
- [primitive Type 과 reference Type](#primitive-Type-과-reference-Type)
- [Wrapper Class](#Wrapper-Class)
- [String, StringBuilder, StringBuffer 의 차이?](#String,-StringBuilder,-StringBuffer-의-차이?)
- [OOP 의 정의와 4가지 특징](#OOP-의-정의와-4가지-특징)
- [OOP 의 5대 원칙](#OOP-의-5대-원칙)
- [객체지향 프로그래밍과 절차지향 프로그래밍의 차이](#객체지향-프로그래밍과-절차지향-프로그래밍의-차이)
- [JVM](#JVM)
- [추상클래스](#추상클래스)
- [인터페이스](#인터페이스)
- [인터페이스와 추상 클래스](#인터페이스와-추상-클래스)
- [클래스, 객체, 인스턴스 차이](#클래스,-객체,-인스턴스-차이)
- [배열과 컬렉션의 차이](#배열과-컬렉션의-차이)
- [Annotation](#Annotation)
- [오버로딩(Overloading)과 오버라이딩(Overriding)](#오버로딩(Overloading)과-오버라이딩(Overriding))
- [Java Collection Framework](#Java-Collection-Framework)
- [제네릭(Generic)](#제네릭(Generic))
- ['==' 와 'equals()' 의 차이](#-와-'equals()'-의-차이)
- [자바에서 멀티스레드 구현방법](#자바에서-멀티스레드-구현방법)
- [Stream 이란?](#Stream-이란?)
- [Lambda란?](#Lambda란?)
- [동기화와 비동기화](#동기화와-비동기화)
- [리플렉션(Reflection)](#리플렉션(Reflection))
- [GC 란?](#GC-란?)
- [GC 의 장점](#GC-의-장점)

<hr>

## Java 와 C 의 차이점
1. c 는 절차지향언어, Java 는 객체지향언어
2. c 는 메모리를 직접 조절가능, Java 는 GC 가 자동으로 메모리 관리
3. c 의 처리속도가 상대적으로 빠름

## Java 언어의 장단점
- 장점
  - 자바는 JVM 을 통해 동작하기 때문에, 운영체제에 독립적이다.
  - 객체지향언어이다.
  - 자동으로 메모리 관리를 해준다.
  - 멀티스레드를 쉽게 구현할 수 있다.
- 단점
  - 비교적 속도가 느리다.
  - 프로그램 발생 시 발생할 수 있는 예외들을 개발자가 직접 처리해야한다. 그렇지 않으면 컴파일이 되지않음.

## 접근제어자의 종류와 특징
|접근제어자|설명|
|---|---|
|public|접근 제한이 없다.|
|protected|같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.|
|default|같은 패키지 내에서만 접근이 가능하다.|
|private|같은 클래스 내에서만 접근이 가능하다.|

## primitive Type 과 reference Type
1. 기본 데이터 타입(Primitive Data Type)
 - 변수에 값 자체를 저장한다.
 - byte, short, char, int, float, double, boolean 이 있다.
 - 기본 타입의 크기가 작고 고정적이기 때문에 메모리의 Stack 영역에 저장된다.
2. 참조형 데이터 타입(Reference Data Type)
 - 메모리상에 객체가 있는 위치를 저장한다.
 - 기본 데이터 타입을 제외한 모든 타입이 참조형 데이터 타입이다.
 - 참조 타입의 데이터의 크기가 가변적, 동적이기 때문에 동적으로 관리되는 Heap 영역에 저장된다.
 - 더 이상 참조하는 변수가 없을 때 가비지 컬렉션에 의해 파괴된다.

## Wrapper Class
기본형 데이터 타입으로 표현할 수 있는 간단한 데이터를 객체로 만들어야 할 경우가 있는데 그러한 기능을 지원하는 클래스를 뜻한다.
|기본형|Wrapper Class|
|---|---|
|byte|Byte|
|short|Short|
|int|Integer|
|long|Long|
|char|Character|
|float|Float|
|double|Double|
|boolean|Boolean|

## String, StringBuilder, StringBuffer 의 차이?
- 공통점
  - 세가지 모두 String(문자열)을 저장하고 관리하는 클래스
- 차이점
  - String 객체는 **불변** 하기때문에 '+' 연산이나 .concat() 메소드를 이용해서 문자열 값에 변화를 줘도 값 자체가 변하는 것이 아니라, 새로 메모리를 할당받아 String 클래스 객체를 만들어서 문자열을 나타낸다.
  - StringBuilder 와 StringBuffer 는 기존 객체의 공간이 부족하게 되는 경우 기존의 버퍼 크기를 늘리며 유연하게 동작한다.(가변적)

**StringBuilder**
- Thread-safe 하지 않음
- StringBuffer 보다 성능이 좋음

**StringBuffer**
- Thread-safe 함(동기화 지원)

### 정리
- 성능 : StringBuilder > StringBuffer > String
- String : 문자열 연산이 적고 멀티쓰레드 환경일 경우
- StringBuffer : 문자열 연산이 많고 멀티쓰레드 환경일 경우
- StringBuilder : 문자열 연산이 많고 단일쓰레드이거나 동기화를 고려하지 않아도 되는 경우  

## OOP 의 정의와 4가지 특징

#### 정의
OOP 란? 현실 세계를 프로그래밍으로 옮겨와 프로그래밍하는 것을 말한다. 현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍 하는 것이다.

#### 특징

1. 추상화(Abstraction)
    - 공통된 속성/ 기능을 묶어 이름을 붙인다.(단순화,객체모델링)
2. 캡슐화(Encapsulation)
    - 높은 응집도, 낮은 결합도를 유지하여 유연함과 유지보수성 증가
    - 외부에서는 생성한 객체가 어떤 메서드와 필드로 일을 수행하는지 모른다.
3. 상속(Inheritance)
    - 자식클래스는 부모클래스를 물려받으며 확장 가능하다.(재사용)
4. 다형성(Polymorphism)
    - 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력(편의성)
    - 여러 가지 데이터를 다룰 수 있는 특성
    - 오버라이딩(Overriding), 오버로딩(Overloading)
  
## OOP 의 5대 원칙

"SOLID" 원칙
- S: 단일 책임 원칙(SRP, Single Responsibility Principle)
    - 객체는 단 하나의 책임만 가져야 한다.
- O: 개방-폐쇄 원칙(OCP,Open Closed Principle)
    - 확장에는 열려있으나 변경에는 닫혀 있어야 한다.
- L: 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
    - 자식클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.
- I: 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
    - 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다.
- D: 의존 역전 원칙(DIP, Dependency Inversion Principle)
    - 의존 관계를 맺을 때, 변화하기 쉬운것 보단 변화하기 어려운 것에 의존해야 한다.

## 객체지향 프로그래밍과 절차지향 프로그래밍의 차이

![img](https://mblogthumb-phinf.pstatic.net/20150121_226/atalanta16_1421824372328vVqK5_JPEG/%C0%FD%C2%F7%C1%F6%C7%E2.jpg?type=w2)
<br>
*출처 : (https://m.blog.naver.com/atalanta16/220249264429)*

> **절차지향 프로그래밍** : 프로그램의 순서와 흐름을 먼저 세우고 필요한 자료구조와 함수들을 설계하는 방식

> **객체지향 프로그래밍** : 자료구조와 이를 중심으로 한 모듈들을 먼저 설계한 다음에 이들의 실행순서와 흐름을 짜는 방식


## JVM

### JVM(Java Virtual Machine)?
- 자바를 실행하기 위해 필요한 가상 머신
- JAVA와 OS 사이에서 중개자 역할을 하며 OS마다 독립적인 플랫폼으로 JAVA가 실행될 수 있게 해줌

### JVM 동작과정
1. 프로그램이 실행되면 JVM 은 OS 로 부터 이 프로그램이 필요로 하는 메모리를 할당받는다.
2. 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어들여 자바 바이트코드(.class)로 변환시킨다.
3. Class Loader를 통해 class 파일들을 JVM 으로 로딩한다.
4. 로딩된 class 파일들을 Execution engine을 통해 해석한다. 
5. 해석된 바이트 코드는 Runtime Data Areas 에 배치되어 실질적인 수행이 이루어지게 된다. 실행 과정 속에서 필요에 따라 GC 작업을 수행한다.

### JVM 구성 
**Java Compiler**
- 자바 소스(.java)코드를 바이트 코드(.class)로 변환
**Class Loader**
- 파일 시점이 아닌 런타임 시점에 동적으로 참조한다.
- 클래스를 처음으로 참조할 때 해당 클래스를 로드한다.
**Execution Engine**
- 클래스 로더가 로드한 바이트 코드를 실행
- 인터프리터, JIT 총 2가지의 방법을 사용
- **Interpreter(인터프리터)**
    - 자바 바이트 코드를 명령어 단위로 읽어서 실행
    - 한 줄 씩 수행하기 때문에 느리다.
- **JIT(Just - In - Time)**
    - 인터프리터 방식의 단점을 보완하기 위해 도입
    - 인터프리터 방식으로 실행하다가 적절한 시점에서 바이트 코드 전체를 컴파일 후에 네이티브 코드로 변경, 이후에는 해당 부분에서 인터프리팅 하지 않고 네이티브 코드로 직접 실행
    - 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행
    - 컴파일 속도가 느리기 때문에 JVM은 내부적으로 해당 메소드가 얼마나 자주 수행되는지 체크하고, 일정 정도를 넘을 때에만 컴파일 수행
    - 한 번만 실행되는 코드라면 컴파일하지 않고 인터프리팅 하는 것이 유리
    - 
**Garbage collector**
 - GC를 수행하는 모듈(스레드)이 있다.

### JVM의 메모리 구조(Runtime Data Area)
프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간

![jvmmemorystructure](https://t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/1RbC/image/ln70NtHgzmHCarXrYWwW20ZCWqQ.png)

<br>

#### Method Area(Class area, Static area)
- 가장 처음 클래스 정보를 올릴 때 저장되는 메모리 공간
- 클래서 로더에 의해 로딩된 클래스, 메소드, 클래스 변수, 전역변수 등을 저장
- 모든 스레드가 공유
- GC의 관리 대상
- Runtime Constant Pool 영역 존재
    - 상수 자료형을 저장하여 실제 메모리 주소를 참조하고 중복을 방지
#### Heap
- Runtime에 동적으로 할당되는 데이터를 저장(new 연산자로 생성된 객체, 배열 등)
- GC의 관리 대상
#### JVM 스택 영역
- Thread가 시작될 때 생성되며 스레드마다 하나씩 존재
- 현재 수행 중인 JVM 명령의 주소를 갖는다.
#### PC Register
- 메소드 호출 시에 임시로 할당되었다가 메소드가 종료되면 소멸(단위 = Frame)
- 매개변수, 지역변수, 리턴 값, 연산 시 발생하는 값을 임시로 저장
#### Native method stack
- 컴파일된 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행
- JAVA가 아닌 다른 언어로 작성된 코드를 위한 공간
- JNI(JAVA Native Interface)를 통해 호출하는 C/C++ 등의 코드를 수행

## 추상클래스

- abstract 키워드로 선언
- 한 개 이상의 미완성 메서드(추상메서드)를 포함하고 있는 클래스라는 의미. 이외에는 본래 클래스와 다른점이 없다.
- 미완성 메서드는 상속을 통해 자손클래스에 의해서만 완성될 수 있다.
- 객체(인스턴스) 생성이 불가능
- 자식 클래스에서 그 기능을 확장하는데 목적이 있다.

## 인터페이스

- interface 키워드로 선언
- 일종의 추상클래스로서, 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 일반 메서드와 멤버변수를 구성원으로 가질 수 없다. 오직 **상수** 와 **추상메서드** 만 구성원으로 가질 수 있다.
- 구현 객체의 같은 동작을 보장하기 위한 목적

## 인터페이스와 추상 클래스
- **공통점**
    - 객체(인스턴스) 생성이 불가능하다.
    - 선언만 있고 구현 내용이 없다.
    - 자식 클래스가 메서드의 구체적인 동작을 구현하도록 책임을 위임한다. 
- **차이점**
    - 서로 다른 목적을 가지고 있다.
        - 추상 클래스는 추상 메서드를 자식 클래스가 구체화하여 그 기능을 확장하는데 목적이 있다.
        - 인터페이스는 서로 고나련이 없는 클래스에서 공통적으로 사용하는 방식이 필요하지만 기능을 각각 구현할 필요가 있는 경우에 사용한다.(구현 객체의 같은 동작을 보장)
    - 추상클래스는 클래스이지만 인터페이스는 클래스가 아니다.
    - 추상클래스는 단일상속이지만 인터페이스는 다중상속이 가능하다. 

## 클래스, 객체, 인스턴스 차이

- **클래스(Class)** 
    - 객체를 만들어 내기 위한 설계도 혹은 틀
    - 연관되어 있는 변수와 메서드의 집합
- **객체(Object)**
    - 소프트웨어 세계에 구현할 대상
    - iv 의 집합  
- **인스턴스(Instance)**
    - 클래스를 바탕으로 메모리에 객체가 구현됬을때 구체적인 실체

## 배열과 컬렉션의 차이

- 배열은 단 하나의 자료형만 저장이 가능하고, 컬렉션은 복수의 자료형을 저장할 수 있다.
- 배열은 고정된 크기이고, 컬렉션은 가변적 크기이다.

## Annotation

어노테이션이란 본래 주석이란 뜻으로, 인터페이스를 기반으로 한 문법이다. 주석과는 그 역할이 다르지만 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있다. 또 해석되는 시점을 정할 수도 있다.(Retention Policy) 어노테이션에는 크게 세 가지 종류가 존재한다. JDK 에 내장되어 있는 built-in annotation과 어노테이션에 대한 정보를 나타내기 위한 어노테이션인 Meta annotation 그리고 개발자가 직접 만들어 내는 Custom Annotation이 있다. built-in annotation 은 상속받아서 메소드를 오버라이드 할 때 나타나는 @Override 어노테이션이 그 대표적인 예이다. 어노테이션의 동작 대상을 결정하는 Meta-Annotation 에도 여러 가지가 존재한다.

## 오버로딩(Overloading)과 오버라이딩(Overriding)

- **오버로딩(Overloading)**
    - 메서드 이름은 같지만 매개변수의 개수나 데이터 형식을 다르게 정의하는 것
    - 다양한 유형의 호출에 대응할 수 있게 하는 방식
- **오버라이딩(Overriding)**
    - 기존에 있는 메서드를 재정의 하는 것으로 매개변수의 개수나 데이터 형식이 같아야한다.
    - 
## Java Collection Framework

- **List**
    - 순서가 있는 데이터의 집합으로 값의 중복을 허용
    - ArrayList, LinkedList, Stack, Vector
- **Set**
    - 순서가 없고 데이터의 중복을 허용하지 않음
    - HashSet, TreeSet 
- **Map**
    - 키와 값의 쌍으로 이루어진 데이터의 집합으로, 키의 중복을 허용하지 않음
    - HashMap, TreeMap, HashTable, Properties

## 제네릭(Generic)
자바에서 안정성을 맡고 있다고 할 수 있다. 컬렉션(Collection)은 복수개의 데이터 타입 요소값이 저장되다 보니 컬렉션 내부에 들어온 값이 내가 원하는 타입인지 알 수 없는데, 제네릭을 통해서 한 가지 타입만 저장하게 되면 별도의 로직처리를 구현할 필요가 없어진다. 또한 api 를 설계하는데 있어서 보다 명확한 의사전달이 가능해진다.

## '==' 와 'equals()' 의 차이

## 자바에서 멀티스레드 구현방법

1. Runnable 인터페이스 구현
2. Thread 클래스 상속
 
## Stream 이란?
## Lambda란?
## 동기화와 비동기화
## 리플렉션(Reflection)
## GC 란?
## GC 의 장점
